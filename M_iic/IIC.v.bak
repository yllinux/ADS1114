/*****************************************************************************

*    Engineer       : yanglei
*    Target Device  : Cyclone IV E ( EP4CE6F17C8 )
*    Tool versions  : Quartus II 12.1
*    Create Date    : 2018-1-12
*    Revision       : v1.0
*    Description    : 仅适用于 ADS1114 或 ADS1115 的I2C模块

*****************************************************************************/

/*--------------------------------------------ADS1114读写步骤-----------------------------------------
1、读操作时（主机读取ADS1114发送的数据）
    主机发送启动信号-主机发送从机地址(R)-从机应答-主机给从机地址指针寄存器赋值-从机应答-主机停止-主机发送启动信号
    -主机发送从机地址(R)-从机应答-主机接收从机数据-主机应答-▪▪▪-主机接收从机数据-主机应答-主机发送停止信号。

2、写操作时（主机向ADS1114写入的数据）
    主机发送启动信号-主机发送从机地址(W)-从机应答-主机给从机地址指针寄存器赋值-从机应答
    -主机发送给从机数据-从机应答-▪▪▪-主机发送给从机数据-从机应答-主机发送停止信号。
*/

module IIC (clk, rst_n, sda, scl, data);

    input          clk;                      //0.2MHz，周期 T = 5us
    input          rst_n; 
     
    inout          sda;                      //串行数据线（双向端口）
    output         scl;                      //串行时钟线
    output [15:0]  data;                     //一个字节输出

    
    reg            scl;
    reg    [15:0]  data;
    reg    [15:0]  data_r;                   //一个字节输出数据寄存
    
//----------------定义ADS1114配置寄存器------------------------
    parameter
        OS          = 1'b1,
        MUX         = 3'b100,
        PGA         = 3'b001,
        MODE        = 1'b1,
        DR          = 3'b111,
        COMP_MODE   = 1'b0,
        COMP_POL    = 1'b0,
        COMP_LAT    = 1'b0,
        COMP_QUE    = 2'b11;
          

    reg [15:0] config_reg; //= {OS, MUX, PGA, MODE, DR, COMP_MODE, COMP_POL, COMP_LAT,COMP_QUE}; //Config Register 配置
     
//----------------从机地址定义(A/D)---------------------------
    parameter         
        SL_ADDR_R   = 8'b1001_0001,          //读操作寻址地址，引脚 ALERT/RDY => GND
        SL_ADDR_W   = 8'b1001_0000;          //写操作寻址地址，引脚 ALERT/RDY => GND
        //SL_ADDR   = 7'b1001_000;           //slave_address 即从机地址，接GND
        //sl_addr   = 7'b1001_001;           //slave_address 即从机地址，接VDD
        //sl_addr   = 7'b1001_010;           //slave_address 即从机地址，接SDA
        //sl_addr   = 7'b1001_011;           //slave_address 即从机地址，接SCL
        
    reg [7:0]  slar;                         //寄存 SL_ADDR_R
    reg [7:0]  slaw;                         //寄存 SL_ADDR_W
         
//----------------定义ADS1114地址指针寄存器--------------------
    parameter     //address_pointer 即地址指针寄存器 
        ADDR_PO_00  = 8'b000000_00,          //Conversion register     转换寄存器包含最后一个转换的结果
        ADDR_PO_01  = 8'b000000_01,          //Config register         配置寄存器用于更改ADS111x操作模式，并查询设备的状态。
        ADDR_PO_10  = 8'b000000_10,          //Lo_thresh register      设置用于比较器函数的阈值值，在ADS1113中不可用
        ADDR_PO_11  = 8'b000000_11;          //Hi_thresh register      设置用于比较器函数的阈值值，在ADS1113中不可用
       
    reg [7:0]  ap_r_00;                      //寄存 ADDR_PO_00
    reg [7:0]  ap_r_01;                      //寄存 ADDR_PO_01

//----------------状态机状态定义------------------------------
    parameter  
        ST_00       = 5'd0,                  //空闲
        ST_01       = 5'd1,                  //启动    
        ST_02       = 5'd2,                  //寻址    
        ST_03       = 5'd3,                  //检测应答   
        ST_04       = 5'd4,                  //指针地址    
        ST_05       = 5'd5,                  //检测应答    
        ST_06       = 5'd6,                  //写入高位寄存器    
        ST_07       = 5'd7,                  //检测应答   
        ST_08       = 5'd8,                  //写入低位寄存器    
        ST_09       = 5'd9,                  //检测应答   
        
        ST_10       = 5'd10,                 //启动    
        ST_11       = 5'd11,                 //寻址
        ST_12       = 5'd12,                 //检测应答
        ST_13       = 5'd13,                 //指针地址
        ST_14       = 5'd14,                 //检测应答
        ST_15       = 5'd15,                 //停止
        
        ST_16       = 5'd16,                 //启动
        ST_17       = 5'd17,                 //寻址
        ST_18       = 5'd18,                 //检测应答
        ST_19       = 5'd19,                 //数据高位
        ST_20       = 5'd20,                 //应答
        ST_21       = 5'd21,                 //数据低位
        ST_22       = 5'd22;                 //应答和数据输出
          


    reg [5:0]  cs;                           //current_state 即现态
  //reg [5:0]  ns;                           //next_state 即次态
    reg        sda_sw;                       //sda_switch 即数据线开关，控制系统是否占有总线控制权
    reg        sda_r;                        //sda_reg 即数据线寄存器
    reg [7:0]  cout1;                        //计数器
     
    assign sda    = sda_sw ? sda_r : 1'bz;
    
//----------------SCL时钟产生---------------------------------
    always @(posedge clk or negedge rst_n)   //0.1MHz，周期 T = 10us,完全满足芯片手册
        if (!rst_n)
            scl            <=  1'b1;         //复位时scl为高电平
        else
            begin   
                if ((cs == ST_00) || (cs == ST_01) || (cs == ST_10) || (cs == ST_15) || (cs == ST_16)) 
                    scl    <=  1'b1;         //空闲时（ST_IDLE），scl为高
                else
                    scl    <=  ~scl;         //当总线忙时，scl为 100KHz的时钟
            end 
            
//----------------有限状态机（FSM）----------------------------
    always @(posedge clk or negedge rst_n)
        if (!rst_n)
            begin 
                sda_r       <=  1'b1;
                sda_sw      <=  1'b1;        //复位时sda线开关 打开，sda线为高电平  
                cout1       <=  8'd0;        //复位时计数器清零  
                cs          <=  ST_00;
            end 
        else 
            begin 
                case (cs)
                    ST_00 :                  //总线处于备用（非忙）状态SDA和SCL都保持高电平
                        begin           
                            sda_r    <=  1'b1;
                            sda_sw   <=  1'b1;
                            cs       <=  ST_01;
                        end 
                          
                    ST_01 :                  //SDA由高变低，SCL保持高电平，为启动信号
                        begin 
                            sda_r    <=  1'b0;
                            sda_sw   <=  1'b1;
                            cs       <=  ST_02;
                          //slar     <=  SL_ADDR_R;  //启动时把地址赋给寄存器
                            slaw     <=  SL_ADDR_W;
                        end 
                          
                    ST_02 :                  //当SCL为高电平时发送8位写操作的地址数据
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    cout1   <=  cout1 + 8'd1;
                                    sda_sw  <=  1'b1;
                                    sda_r   <=  slaw[7];
                                    slaw    <=  {slaw[6:0], slaw[7]};  //移位左循环
                                    cs      <=  ST_02;
                                    
                                    /*
                                    case (cout1)
                                        8'd0 : sda_r  <=  SL_ADDR_W[7];
                                        8'd1 : sda_r  <=  SL_ADDR_W[6];
                                        8'd2 : sda_r  <=  SL_ADDR_W[5];
                                        8'd3 : sda_r  <=  SL_ADDR_W[4];
                                        8'd4 : sda_r  <=  SL_ADDR_W[3];
                                        8'd5 : sda_r  <=  SL_ADDR_W[2];
                                        8'd6 : sda_r  <=  SL_ADDR_W[1];
                                        8'd7 : sda_r  <=  SL_ADDR_W[0];
                                        default : sda_r  <=  sda_r;
                                    endcase  
                                    */
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'bz;  //此句可省，令sda_sw为低就已经使sda线为高阻态了
                                        sda_sw  <=  1'b0;  //sda线开关 关闭，以便接收从机应答信号
                                        cs      <=  ST_03;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_02;
                                    end 
                        end 
                          
                    ST_03 :                 //检测从机应答
                        begin 
                            if (!sda)
                                begin 
                                    ap_r_01  <=  ADDR_PO_01;
                                    cs       <=  ST_04;
                                end 
                            else 
                                begin
                                    cs       <=  ST_03;     //若没有检测到从机应答，则继续检测应答
                                  //cs       <=  ST_00;     //若没有检测到从机应答，则跳转到空闲（ST_IDLE）状态
                                end 
                        end 
                      
                    ST_04 :                 //当SCL为高电平时发送8位寄存器地址指针数据
                        begin
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    sda_sw   <=  1'b1;  //获得SDA线控制权
                                    cout1    <=  cout1 + 8'd1;
                                    sda_r    <=  ap_r_01[7];
                                    ap_r_01  <=  {ap_r_01[6:0], ap_r_01[7]};  //移位左循环
                                    cs       <=  ST_04;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'bz;  //此句可省，令sda_sw为低就已经使sda线为高阻态了
                                        sda_sw  <=  1'b0;  //sda线开关 关闭，以便接收从机应答信号
                                        cs      <=  ST_05;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_04;
                                    end 
                        end 
                    
                    ST_05 :                 //检测从机应答 
                        begin 
                            if (!sda)
                                begin 
                                    config_reg  <=  {OS, MUX, PGA, MODE, DR, COMP_MODE, COMP_POL, COMP_LAT,COMP_QUE}; //Config Register 配置
                                    cs          <=  ST_06;
                                end 
                            else 
                                begin
                                    cs          <=  ST_05;     //若没有检测到从机应答，则继续检测应答
                                  //cs          <=  ST_00;     //若没有检测到从机应答，则跳转到空闲（ST_IDLE）状态
                                end     
                        end   
                   
                   
                    ST_06 :                 //把配置数据写入高 8 位寄存器
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    sda_sw     <=  1'b1;  //获得SDA线控制权
                                    cout1      <=  cout1 + 8'd1;
                                    sda_r      <=  config_reg[15];
                                    config_reg <=  {config_reg[14:0], config_reg[15]};  //移位左循环
                                    cs         <=  ST_06;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'bz;  //此句可省，令sda_sw为低就已经使sda线为高阻态了
                                        sda_sw  <=  1'b0;  //sda线开关 关闭，以便接收从机应答信号
                                        cs      <=  ST_07;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_06;
                                    end      
                        end 
                      
                    ST_07 :                 //检测从机应答 
                        begin 
                            if (!sda)
                                begin 
                                    cs          <=  ST_08;
                                end 
                            else 
                                begin
                                    cs          <=  ST_07;     //若没有检测到从机应答，则继续检测应答
                                  //cs          <=  ST_00;     //若没有检测到从机应答，则跳转到空闲（ST_IDLE）状态
                                end     
                        end 
                      
                    ST_08 :                 //把配置数据写入低 8 位寄存器 
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    sda_sw     <=  1'b1;  //获得SDA线控制权
                                    cout1      <=  cout1 + 8'd1;
                                    sda_r      <=  config_reg[15];
                                    config_reg <=  {config_reg[14:0], config_reg[15]};  //移位左循环
                                    cs         <=  ST_08;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'bz;  //此句可省，令sda_sw为低就已经使sda线为高阻态了
                                        sda_sw  <=  1'b0;  //sda线开关 关闭，以便接收从机应答信号
                                        cs      <=  ST_09;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_08;
                                    end       
                        end 
                      
                    ST_09 :                 //检测从机应答  
                        begin 
                            if (!sda)
                                begin 
                                    cs          <=  ST_10;
                                end 
                            else 
                                begin
                                    cs          <=  ST_09;     //若没有检测到从机应答，则继续检测应答
                                  //cs          <=  ST_00;     //若没有检测到从机应答，则跳转到空闲（ST_IDLE）状态
                                end    
                        end 
                        
                    ST_10 :                 //重复启动信号 
                        begin 
                            sda_r    <=  1'b0;
                            sda_sw   <=  1'b1;
                            slar     <=  SL_ADDR_R;  //启动时把地址赋给寄存器
                          //slaw     <=  SL_ADDR_W;        
                            cs       <=  ST_11;
                        end 
                    
                    ST_11 :                 //当SCL为高电平时发送8位读操作的地址数据 
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    cout1   <=  cout1 + 8'd1;
                                    sda_sw  <=  1'b1;
                                    sda_r   <=  slar[7];
                                    slar    <=  {slar[6:0], slar[7]};  //移位左循环
                                    cs      <=  ST_11;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'bz;  //此句可省，令sda_sw为低就已经使sda线为高阻态了
                                        sda_sw  <=  1'b0;  //sda线开关 关闭，以便接收从机应答信号
                                        cs      <=  ST_12;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_11;
                                    end     
                        end 
                    
                    ST_12 :                 //检测从机应答  
                        begin 
                            if (!sda)
                                begin 
                                    ap_r_00  <=  ADDR_PO_00;
                                    cs       <=  ST_13;
                                end 
                            else 
                                begin
                                    cs       <=  ST_12;     //若没有检测到从机应答，则继续检测应答
                                  //cs       <=  ST_00;     //若没有检测到从机应答，则跳转到空闲（ST_IDLE）状态
                                end     
                        end 
                        
                    ST_13 :                 //当SCL为高电平时发送8位寄存器地址指针数据
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    sda_sw   <=  1'b1;  //获得SDA线控制权
                                    cout1    <=  cout1 + 8'd1;
                                    sda_r    <=  ap_r_00[7];
                                    ap_r_00  <=  {ap_r_00[6:0], ap_r_00[7]};  //移位左循环
                                    cs       <=  ST_13;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'bz;  //此句可省，令sda_sw为低就已经使sda线为高阻态了
                                        sda_sw  <=  1'b0;  //sda线开关 关闭，以便接收从机应答信号
                                        cs      <=  ST_14;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_13;
                                    end     
                        end 
                        
                    ST_14 :                 //检测从机应答  
                        begin 
                            if (!sda)
                                begin  
                                    cs          <=  ST_15;
                                end 
                            else 
                                begin
                                    cs          <=  ST_14;     //若没有检测到从机应答，则继续检测应答
                                  //cs          <=  ST_00;     //若没有检测到从机应答，则跳转到空闲（ST_IDLE）状态
                                end      
                        end 
                        
                    ST_15 :                 //主机停止，SDA 由低变高，SCL保持高电平，为停止信号
                        begin 
                            if (cout1 < 8'd1)
                                begin 
                                    cout1    <=  cout1 + 8'd1;
                                    sda_sw   <=  1'b1;  //获得SDA线控制权  
                                    sda_r    <=  1'b0;
                                    cs       <=  ST_15;
                                end 
                            else 
                                if (cout1 == 1)
                                    begin 
                                        sda_sw   <=  1'b1;  //获得SDA线控制权  
                                        sda_r    <=  1'b1;
                                        cout1    <=  8'd0;
                                        cs       <=  ST_16;
                                    end 
                        end 
                        
                    ST_16 :                 //读状态启动信号 
                        begin 
                            sda_r    <=  1'b0;
                            sda_sw   <=  1'b1;
                            slar     <=  SL_ADDR_R;  //启动时把地址赋给寄存器
                            cs       <=  ST_17;
                        end 
                        
                    ST_17 :                 //当SCL为高电平时发送8位读操作的地址数据  
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    cout1   <=  cout1 + 8'd1;
                                    sda_sw  <=  1'b1;
                                    sda_r   <=  slar[7];
                                    slar    <=  {slar[6:0], slar[7]};  //移位左循环
                                    cs      <=  ST_17;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'bz;  //此句可省，令sda_sw为低就已经使sda线为高阻态了
                                        sda_sw  <=  1'b0;  //sda线开关 关闭，以便接收从机应答信号
                                        cs      <=  ST_18;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_17;
                                    end         
                        end 
                        
                    ST_18 :                 //检测从机应答 
                        begin 
                            if (!sda)
                                begin 
                                    ap_r_00  <=  ADDR_PO_00;
                                    cs       <=  ST_19;
                                end 
                            else 
                                begin
                                    cs       <=  ST_18;     //若没有检测到从机应答，则继续检测应答
                                  //cs       <=  ST_00;     //若没有检测到从机应答，则跳转到空闲（ST_IDLE）状态
                                end         
                        end 
                        
                    ST_19 :                 //主机接收数据高 8 位 
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    sda_sw     <=  1'b0;    //释放 SDA 线控制权
                                    cout1      <=  cout1 + 8'd1;
                                    data_r     <=  {data_r[14:0], sda};
                                    cs         <=  ST_19;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'b0;  //使sda线为低电平，发送应答信号
                                        sda_sw  <=  1'b1;  //sda线开关 打开，以便向从机发送应答信号
                                        cs      <=  ST_20;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_19;
                                    end         
                        end 
                        
                    ST_20 :                 //主机产生应答信号 
                        begin 
                            sda_sw   <=  1'b0;  //释放 SDA 线控制权        
                            cs       <=  ST_21;
                        end 
                        
                    ST_21 :                 // 
                        begin 
                            if ((scl == 1'b0) && (cout1 < 8'd8))
                                begin 
                                    sda_sw     <=  1'b0;    //释放 SDA 线控制权
                                    cout1      <=  cout1 + 8'd1;
                                    data_r     <=  {data_r[14:0], sda};
                                    cs         <=  ST_21;
                                end 
                            else
                                if ((scl == 1'b0) && (cout1 == 8'd8))
                                    begin
                                        cout1   <=  8'd0;
                                        sda_r   <=  1'b0;  //使sda线为低电平，发送应答信号
                                        sda_sw  <=  1'b1;  //sda线开关 打开，以便向从机发送应答信号
                                        cs      <=  ST_22;
                                    end 
                                else 
                                    begin 
                                        cs      <=  ST_21;
                                    end     
                        end 
                        
                    ST_22 :                 // 
                        begin
                            sda_sw   <=  1'b0;  //释放 SDA 线控制权
                            data     <=  data_r;       
                            cs       <=  ST_19;
                        end 
                    default : cs     <=  ST_00;
                endcase   
            end 
endmodule